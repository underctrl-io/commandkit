import { build } from 'tsup';
import {
  CompilerPlugin,
  CompilerPluginRuntime,
  fromEsbuildPlugin,
} from '../plugins';
import { loadConfigFile } from '../config/loader';
import { writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { DevEnv, devEnvFileArgs, ProdEnv, prodEnvFileArgs } from './env';
import { rimraf } from 'rimraf';
import { performTypeCheck } from './type-checker';
import { copyLocaleFiles } from './common';

export interface ApplicationBuildOptions {
  plugins?: CompilerPlugin[];
  esbuildPlugins?: any[];
  isDev?: boolean;
  configPath?: string;
}

export async function buildApplication({
  plugins,
  esbuildPlugins,
  isDev,
  configPath,
}: ApplicationBuildOptions) {
  const config = await loadConfigFile(configPath);

  if (!isDev && !config?.typescript?.ignoreBuildErrors) {
    await performTypeCheck(configPath || process.cwd());
  }

  const pluginRuntime = new CompilerPluginRuntime(plugins || []);
  const esbuildPluginList: any[] = pluginRuntime.isEmpty()
    ? []
    : [pluginRuntime.toEsbuildPlugin()];

  if (esbuildPlugins?.length) {
    esbuildPluginList.push(...esbuildPlugins.map(fromEsbuildPlugin));
  }

  try {
    const dest = isDev ? '.commandkit' : config.distDir;

    // Clean the destination directory
    await rimraf(dest);

    await build({
      esbuildPlugins: esbuildPluginList,
      watch: false,
      banner: {
        js: !isDev
          ? '/* Optimized production build generated by commandkit */'
          : '',
      },
      cjsInterop: true,
      dts: false,
      clean: true,
      format: ['esm'],
      shims: true,
      keepNames: true,
      minify: false,
      jsxFactory: 'CommandKit.createElement',
      jsxFragment: 'CommandKit.Fragment',
      minifyIdentifiers: false,
      minifySyntax: false,
      silent: !!isDev,
      splitting: true,
      skipNodeModulesBundle: true,
      name: 'CommandKit',
      sourcemap: true,
      target: 'node16',
      outDir: dest,
      env: (isDev ? DevEnv(true) : ProdEnv(true)) as Record<string, string>,
      entry: [
        'src',
        `!${config.distDir}`,
        '!.commandkit',
        '!**/*.test.*',
        '!**/*.spec.*',
      ],
    });

    await copyLocaleFiles('src', dest);
    await injectEntryFile(configPath || process.cwd(), !!isDev, config.distDir);
  } catch (error) {
    console.error('Build failed:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.stack);
    }
    process.exit(1); // Force exit on error
  } finally {
    // Ensure plugins are cleaned up
    await pluginRuntime.cleanup();
  }
}

const envScript = (dev: boolean) => `// --- Environment Variables Loader ---
const $env = [${(dev ? devEnvFileArgs : prodEnvFileArgs).map((p) => `"${p}"`).join(', ')}];
for (const file of $env) {
  try {
    process.loadEnvFile(file);
    console.log('\\x1b[36mâœ” Loaded \\x1b[0m\\x1b[33m%s\\x1b[0m', file);
  } catch {}
}
`;

const requireScript = [
  '// --- CommandKit require() polyfill ---',
  '  if (typeof require === "undefined") {',
  '    const { createRequire } = await import("node:module");',
  '    const __require = createRequire(import.meta.url);',
  '    Object.defineProperty(globalThis, "require", {',
  '      value: (id) => {',
  '        return __require(id);',
  '      },',
  '      configurable: true,',
  '      enumerable: false,',
  '      writable: true,',
  '    });',
  '  }',
  '// --- CommandKit require() polyfill ---',
].join('\n');

const antiCrashScript = [
  '// --- CommandKit Anti-Crash Monitor ---',
  "  // 'uncaughtException' event is supposed to be used to perform synchronous cleanup before shutting down the process",
  '  // instead of using it as a means to resume operation.',
  '  // But it exists here due to compatibility reasons with discord bot ecosystem.',
  "  const p = (t) => `\\x1b[31m${t}\\x1b[0m`, b = '[CommandKit Anti-Crash Monitor]', l = console.log, e1 = 'uncaughtException', e2 = 'unhandledRejection';",
  '  if (!process.eventNames().includes(e1)) // skip if it is already handled',
  '    process.on(e1, (e) => {',
  '      l(p(`${b} Uncaught Exception`)); l(p(b), p(e.stack || e));',
  '    })',
  '  if (!process.eventNames().includes(e2)) // skip if it is already handled',
  '    process.on(e2, (r) => {',
  '      l(p(`${b} Unhandled promise rejection`)); l(p(`${b} ${r.stack || r}`));',
  '    });',
  '// --- CommandKit Anti-Crash Monitor ---',
].join('\n');

const wrapInAsyncIIFE = (code: string[]) =>
  `;await (async () => {\n${code.join('\n\n')}\n})();`;

async function injectEntryFile(
  configPath: string,
  isDev: boolean,
  distDir?: string,
) {
  const code = `/* Entrypoint File Generated By CommandKit */
${isDev ? `\n\n// Injected for development\n${wrapInAsyncIIFE([envScript(isDev), antiCrashScript, requireScript])}\n\n` : wrapInAsyncIIFE([envScript(isDev), requireScript])}

import { CommandKit } from 'commandkit';
import app from './app.js';

async function bootstrap() {
  const commandkit = new CommandKit({
    client: app,
  });

  await commandkit.start();
}

await bootstrap().catch((e) => {
  console.error('Failed to bootstrap CommandKit application:\\n', e.stack);
})
`;

  const dist = isDev ? '.commandkit' : distDir || 'dist';

  await writeFile(join(configPath, dist, 'index.js'), code);
}
