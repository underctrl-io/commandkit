import { build } from 'tsdown';
import { CompilerPlugin, CompilerPluginRuntime } from '../plugins';
import { loadConfigFile } from '../config/loader';
import { writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { DevEnv, devEnvFileArgs, ProdEnv, prodEnvFileArgs } from './env';
import { rimraf } from 'rimraf';
import { performTypeCheck } from './type-checker';
import { copyLocaleFiles } from './common';
import { MaybeArray } from '../components';

export interface ApplicationBuildOptions {
  plugins?: MaybeArray<CompilerPlugin>[] | Array<CompilerPlugin>;
  rolldownPlugins?: any[];
  isDev?: boolean;
  configPath?: string;
}

// emit public env variables and given env variables
function mergeDefinitionsIfNeeded(env: Record<string, string>) {
  const values = Object.fromEntries(
    Object.entries(process.env).filter(
      ([k]) => !(k in env) && k.startsWith('COMMANDKIT_PUBLIC_'),
    ),
  );

  return {
    ...env,
    ...values,
  };
}

export async function buildApplication({
  plugins,
  rolldownPlugins,
  isDev,
  configPath,
}: ApplicationBuildOptions) {
  const config = await loadConfigFile(configPath);

  if (!isDev && !config?.typescript?.ignoreBuildErrors) {
    await performTypeCheck(configPath || process.cwd());
  }

  const pluginRuntime = new CompilerPluginRuntime(
    (plugins || []) as CompilerPlugin[],
  );

  rolldownPlugins ??= [];

  rolldownPlugins.push(pluginRuntime.toJSON());

  try {
    const dest = isDev ? '.commandkit' : config.distDir;

    // Clean the destination directory
    await rimraf(dest);

    await pluginRuntime.init();

    await build({
      watch: false,
      dts: false,
      clean: true,
      format: ['esm'],
      shims: true,
      minify: false,
      silent: !!isDev,
      inputOptions: {
        transform: {
          jsx: {
            runtime: 'automatic',
            importSource: 'commandkit',
          },
        },
        moduleTypes: {
          '.json': 'js',
          '.node': 'binary',
        },
      },
      plugins: rolldownPlugins,
      platform: 'node',
      skipNodeModulesBundle: true,
      sourcemap: true,
      target: 'node16',
      outDir: dest,
      env: mergeDefinitionsIfNeeded(config.env || {}),
      entry: [
        'src',
        `!${config.distDir}`,
        '!.commandkit',
        '!**/*.test.*',
        '!**/*.spec.*',
      ],
      unbundle: !!isDev,
    });

    await copyLocaleFiles('src', dest);
    await injectEntryFile(configPath || process.cwd(), !!isDev, config.distDir);
  } catch (error) {
    console.error('Build failed:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.stack);
    }
    process.exit(1); // Force exit on error
  } finally {
    // Ensure plugins are cleaned up
    await pluginRuntime.destroy();
  }
}

const envScript = (dev: boolean) => `// --- Environment Variables Loader ---
const $env = [${(dev ? devEnvFileArgs : prodEnvFileArgs).map((p) => `"${p}"`).join(', ')}];
for (const file of $env) {
  try {
    process.loadEnvFile(file);
    console.log('\\x1b[36mâœ” Loaded \\x1b[0m\\x1b[33m%s\\x1b[0m', file);
  } catch {}
}
`;

const antiCrashScript = [
  '// --- CommandKit Anti-Crash Monitor ---',
  "  // 'uncaughtException' event is supposed to be used to perform synchronous cleanup before shutting down the process",
  '  // instead of using it as a means to resume operation.',
  '  // But it exists here due to compatibility reasons with discord bot ecosystem.',
  "  const p = (t) => `\\x1b[31m${t}\\x1b[0m`, b = '[CommandKit Anti-Crash Monitor]', l = console.log, e1 = 'uncaughtException', e2 = 'unhandledRejection';",
  '  if (!process.eventNames().includes(e1)) // skip if it is already handled',
  '    process.on(e1, (e) => {',
  '      l(p(`${b} Uncaught Exception`)); l(p(b), p(e.stack || e));',
  '    })',
  '  if (!process.eventNames().includes(e2)) // skip if it is already handled',
  '    process.on(e2, (r) => {',
  '      l(p(`${b} Unhandled promise rejection`)); l(p(`${b} ${r.stack || r}`));',
  '    });',
  '// --- CommandKit Anti-Crash Monitor ---',
].join('\n');

const wrapInAsyncIIFE = (code: string[]) =>
  `;await (async () => {\n${code.join('\n\n')}\n})();`;

async function injectEntryFile(
  configPath: string,
  isDev: boolean,
  distDir?: string,
) {
  const code = `/* Entrypoint File Generated By CommandKit */
${isDev ? `\n\n// Injected for development\n${wrapInAsyncIIFE([envScript(isDev), antiCrashScript])}\n\n` : wrapInAsyncIIFE([envScript(isDev)])}

import { commandkit } from 'commandkit';
import { Client } from 'discord.js';

async function bootstrap() {
  const app = await import('./app.js').then((m) => m.default ?? m);

  if (!app || !(app instanceof Client)) {
    throw new Error('The app file must default export the discord.js client instance');
  }

  commandkit.setClient(app);

  await commandkit.start();
}

await bootstrap().catch((e) => {
  console.error('Failed to bootstrap CommandKit application:\\n', e.stack);
})
`;

  const dist = isDev ? '.commandkit' : distDir || 'dist';

  await writeFile(join(configPath, dist, 'index.js'), code);
}
